// @cropper/element-selection@2.1.0 downloaded from https://ga.jspm.io/npm:@cropper/element-selection@2.1.0/dist/element-selection.esm.raw.js

import t from"@cropper/element";import{EVENT_CHANGE as e,on as i,EVENT_KEYDOWN as s,off as h,isPositiveNumber as a,CROPPER_CANVAS as n,EVENT_ACTION_START as o,EVENT_ACTION_END as r,EVENT_ACTION as c,CROPPER_SELECTION as l,getAdjustedSizes as d,getComposedPathTarget as $,ACTION_SELECT as f,ACTION_SCALE as u,getOffset as v,ACTION_MOVE as g,ACTION_RESIZE_NORTHWEST as p,ACTION_RESIZE_SOUTHWEST as m,ACTION_RESIZE_NORTHEAST as b,ACTION_RESIZE_SOUTHEAST as y,ACTION_RESIZE_WEST as w,ACTION_RESIZE_EAST as k,ACTION_RESIZE_SOUTH as x,ACTION_RESIZE_NORTH as A,isNumber as S,isPlainObject as C,CROPPER_IMAGE as D,isFunction as E}from"@cropper/utils";var T=':host{display:block;left:0;position:relative;right:0}:host([outlined]){outline:1px solid var(--theme-color)}:host([multiple]){outline:1px dashed hsla(0,0%,100%,.5)}:host([multiple]):after{bottom:0;content:"";cursor:pointer;display:block;left:0;position:absolute;right:0;top:0}:host([multiple][active]){outline-color:var(--theme-color);z-index:1}:host([multiple])>*{visibility:hidden}:host([multiple][active])>*{visibility:visible}:host([multiple][active]):after{display:none}';const R=new WeakMap;class CropperSelection extends t{constructor(){super(...arguments);this.$onCanvasAction=null;this.$onCanvasActionStart=null;this.$onCanvasActionEnd=null;this.$onDocumentKeyDown=null;this.$action="";this.$actionStartTarget=null;this.$changing=false;this.$style=T;this.$initialSelection={x:0,y:0,width:0,height:0};this.x=0;this.y=0;this.width=0;this.height=0;this.aspectRatio=NaN;this.initialAspectRatio=NaN;this.initialCoverage=NaN;this.active=false;this.linked=false;this.dynamic=false;this.movable=false;this.resizable=false;this.zoomable=false;this.multiple=false;this.keyboard=false;this.outlined=false;this.precise=false}set $canvas(t){R.set(this,t)}get $canvas(){return R.get(this)}static get observedAttributes(){return super.observedAttributes.concat(["active","aspect-ratio","dynamic","height","initial-aspect-ratio","initial-coverage","keyboard","linked","movable","multiple","outlined","precise","resizable","width","x","y","zoomable"])}$propertyChangedCallback(t,n,o){if(!Object.is(o,n)){super.$propertyChangedCallback(t,n,o);switch(t){case"x":case"y":case"width":case"height":this.$changing||this.$nextTick((()=>{this.$change(this.x,this.y,this.width,this.height,this.aspectRatio,true)}));break;case"aspectRatio":case"initialAspectRatio":this.$nextTick((()=>{this.$initSelection()}));break;case"initialCoverage":this.$nextTick((()=>{a(o)&&o<=1&&this.$initSelection(true,true)}));break;case"keyboard":this.$nextTick((()=>{if(this.$canvas)if(o){if(!this.$onDocumentKeyDown){this.$onDocumentKeyDown=this.$handleKeyDown.bind(this);i(this.ownerDocument,s,this.$onDocumentKeyDown)}}else if(this.$onDocumentKeyDown){h(this.ownerDocument,s,this.$onDocumentKeyDown);this.$onDocumentKeyDown=null}}));break;case"multiple":this.$nextTick((()=>{if(this.$canvas){const t=this.$getSelections();if(o){t.forEach((t=>{t.active=false}));this.active=true;this.$emit(e,{x:this.x,y:this.y,width:this.width,height:this.height})}else{this.active=false;t.slice(1).forEach((t=>{this.$removeSelection(t)}))}}}));break;case"precise":this.$nextTick((()=>{this.$change(this.x,this.y)}));break;case"linked":o&&(this.dynamic=true);break}}}connectedCallback(){super.connectedCallback();const t=this.closest(this.$getTagNameOf(n));if(t){this.$canvas=t;this.$setStyles({position:"absolute",transform:`translate(${this.x}px, ${this.y}px)`});this.hidden||this.$render();this.$initSelection(true);this.$onCanvasActionStart=this.$handleActionStart.bind(this);this.$onCanvasActionEnd=this.$handleActionEnd.bind(this);this.$onCanvasAction=this.$handleAction.bind(this);i(t,o,this.$onCanvasActionStart);i(t,r,this.$onCanvasActionEnd);i(t,c,this.$onCanvasAction)}else this.$render()}disconnectedCallback(){const{$canvas:t}=this;if(t){if(this.$onCanvasActionStart){h(t,o,this.$onCanvasActionStart);this.$onCanvasActionStart=null}if(this.$onCanvasActionEnd){h(t,r,this.$onCanvasActionEnd);this.$onCanvasActionEnd=null}if(this.$onCanvasAction){h(t,c,this.$onCanvasAction);this.$onCanvasAction=null}}super.disconnectedCallback()}$getSelections(){let t=[];this.parentElement&&(t=Array.from(this.parentElement.querySelectorAll(this.$getTagNameOf(l))));return t}$initSelection(t=false,e=false){const{initialCoverage:i,parentElement:s}=this;if(a(i)&&s){const h=this.aspectRatio||this.initialAspectRatio;let n=(e?0:this.width)||s.offsetWidth*i;let o=(e?0:this.height)||s.offsetHeight*i;a(h)&&({width:n,height:o}=d({aspectRatio:h,width:n,height:o}));this.$change(this.x,this.y,n,o);t&&this.$center();this.$initialSelection={x:this.x,y:this.y,width:this.width,height:this.height}}}$createSelection(){const t=this.cloneNode(true);this.hasAttribute("id")&&t.removeAttribute("id");t.initialCoverage=NaN;this.active=false;this.parentElement&&this.parentElement.insertBefore(t,this.nextSibling);return t}$removeSelection(t=this){if(this.parentElement){const i=this.$getSelections();if(i.length>1){const s=i.indexOf(t);const h=i[s+1]||i[s-1];if(h){t.active=false;this.parentElement.removeChild(t);h.active=true;h.$emit(e,{x:h.x,y:h.y,width:h.width,height:h.height})}}else this.$clear()}}$handleActionStart(t){var i,s;const h=(s=(i=t.detail)===null||i===void 0?void 0:i.relatedEvent)===null||s===void 0?void 0:s.target;this.$action="";this.$actionStartTarget=h;if(!this.hidden&&this.multiple&&!this.active&&h===this&&this.parentElement){this.$getSelections().forEach((t=>{t.active=false}));this.active=true;this.$emit(e,{x:this.x,y:this.y,width:this.width,height:this.height})}}$handleAction(t){const{currentTarget:e,detail:i}=t;if(!e||!i)return;const{relatedEvent:s}=i;let{action:h}=i;const n=s?$(s):null;if(!h&&this.multiple){h=this.$action||(n===null||n===void 0?void 0:n.action);this.$action=h}if(!h||this.hidden&&h!==f||this.multiple&&!this.active&&h!==u)return;const{width:o,height:r}=this;let c=i.endX-i.startX;let l=i.endY-i.startY;let{aspectRatio:d}=this;!a(d)&&s.shiftKey&&(d=a(o)&&a(r)?o/r:1);switch(h){case f:if(c!==0||l!==0){c===0?c=l:l===0&&(l=c);const{$canvas:t}=this;const s=v(e);(this.multiple&&!this.hidden?this.$createSelection():this).$change(i.startX-s.left,i.startY-s.top,Math.abs(c),Math.abs(l),d);c<0?l<0?h=p:l>0&&(h=m):c>0&&(l<0?h=b:l>0&&(h=y));t&&(t.$action=h)}break;case g:this.movable&&(this.dynamic||this.$actionStartTarget&&this.contains(this.$actionStartTarget))&&this.$move(c,l);break;case u:if(s&&this.zoomable&&(this.dynamic||this.contains(s.target))){const t=v(e);this.$zoom(i.scale,s.pageX-t.left,s.pageY-t.top)}break;default:this.$resize(h,c,l,d)}}$handleActionEnd(){this.$action="";this.$actionStartTarget=null}$handleKeyDown(t){if(this.hidden||!this.keyboard||this.multiple&&!this.active||t.defaultPrevented)return;const{activeElement:e}=document;if(!e||!["INPUT","TEXTAREA"].includes(e.tagName)&&!["true","plaintext-only"].includes(e.contentEditable))switch(t.key){case"Backspace":if(t.metaKey){t.preventDefault();this.$removeSelection()}break;case"Delete":t.preventDefault();this.$removeSelection();break;case"ArrowLeft":t.preventDefault();this.$move(-1,0);break;case"ArrowRight":t.preventDefault();this.$move(1,0);break;case"ArrowUp":t.preventDefault();this.$move(0,-1);break;case"ArrowDown":t.preventDefault();this.$move(0,1);break;case"+":t.preventDefault();this.$zoom(.1);break;case"-":t.preventDefault();this.$zoom(-.1);break}}
/**
     * Aligns the selection to the center of its parent element.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$center(){const{parentElement:t}=this;if(!t)return this;const e=(t.offsetWidth-this.width)/2;const i=(t.offsetHeight-this.height)/2;return this.$change(e,i)}
/**
     * Moves the selection.
     * @param {number} x The moving distance in the horizontal direction.
     * @param {number} [y] The moving distance in the vertical direction.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$move(t,e=t){return this.$moveTo(this.x+t,this.y+e)}
/**
     * Moves the selection to a specific position.
     * @param {number} x The new position in the horizontal direction.
     * @param {number} [y] The new position in the vertical direction.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$moveTo(t,e=t){return this.movable?this.$change(t,e):this}
/**
     * Adjusts the size the selection on a specific side or corner.
     * @param {string} action Indicates the side or corner to resize.
     * @param {number} [offsetX] The horizontal offset of the specific side or corner.
     * @param {number} [offsetY] The vertical offset of the specific side or corner.
     * @param {number} [aspectRatio] The aspect ratio for computing the new size if it is necessary.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$resize(t,e=0,i=0,s=this.aspectRatio){if(!this.resizable)return this;const h=a(s);const{$canvas:n}=this;let{x:o,y:r,width:c,height:l}=this;switch(t){case A:r+=i;l-=i;if(l<0){t=x;l=-l;r-=l}if(h){e=i*s;o+=e/2;c-=e;if(c<0){c=-c;o-=c}}break;case k:c+=e;if(c<0){t=w;c=-c;o-=c}if(h){i=e/s;r-=i/2;l+=i;if(l<0){l=-l;r-=l}}break;case x:l+=i;if(l<0){t=A;l=-l;r-=l}if(h){e=i*s;o-=e/2;c+=e;if(c<0){c=-c;o-=c}}break;case w:o+=e;c-=e;if(c<0){t=k;c=-c;o-=c}if(h){i=e/s;r+=i/2;l-=i;if(l<0){l=-l;r-=l}}break;case b:h&&(i=-e/s);r+=i;l-=i;c+=e;if(c<0&&l<0){t=m;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=p;c=-c;o-=c}else if(l<0){t=y;l=-l;r-=l}break;case p:h&&(i=e/s);o+=e;r+=i;c-=e;l-=i;if(c<0&&l<0){t=y;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=b;c=-c;o-=c}else if(l<0){t=m;l=-l;r-=l}break;case y:h&&(i=e/s);c+=e;l+=i;if(c<0&&l<0){t=p;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=m;c=-c;o-=c}else if(l<0){t=b;l=-l;r-=l}break;case m:h&&(i=-e/s);o+=e;c-=e;l+=i;if(c<0&&l<0){t=b;c=-c;l=-l;o-=c;r-=l}else if(c<0){t=y;c=-c;o-=c}else if(l<0){t=p;l=-l;r-=l}break}n&&n.$setAction(t);return this.$change(o,r,c,l)}
/**
     * Zooms the selection.
     * @param {number} scale The zoom factor. Positive numbers for zooming in, and negative numbers for zooming out.
     * @param {number} [x] The zoom origin in the horizontal, defaults to the center of the selection.
     * @param {number} [y] The zoom origin in the vertical, defaults to the center of the selection.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$zoom(t,e,i){if(!this.zoomable||t===0)return this;t<0?t=1/(1-t):t+=1;const{width:s,height:h}=this;const a=s*t;const n=h*t;let o=this.x;let r=this.y;if(S(e)&&S(i)){o-=(a-s)*((e-this.x)/s);r-=(n-h)*((i-this.y)/h)}else{o-=(a-s)/2;r-=(n-h)/2}return this.$change(o,r,a,n)}
/**
     * Changes the position and/or size of the selection.
     * @param {number} x The new position in the horizontal direction.
     * @param {number} y The new position in the vertical direction.
     * @param {number} [width] The new width.
     * @param {number} [height] The new height.
     * @param {number} [aspectRatio] The new aspect ratio for this change only.
     * @param {number} [_force] Force change.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$change(t,i,s=this.width,h=this.height,n=this.aspectRatio,o=false){if(this.$changing||!S(t)||!S(i)||!S(s)||!S(h)||s<0||h<0)return this;a(n)&&({width:s,height:h}=d({aspectRatio:n,width:s,height:h},"cover"));if(!this.precise){t=Math.round(t);i=Math.round(i);s=Math.round(s);h=Math.round(h)}if(t===this.x&&i===this.y&&s===this.width&&h===this.height&&Object.is(n,this.aspectRatio)&&!o)return this;this.hidden&&(this.hidden=false);if(this.$emit(e,{x:t,y:i,width:s,height:h})===false)return this;this.$changing=true;this.x=t;this.y=i;this.width=s;this.height=h;this.$changing=false;return this.$render()}
/**
     * Resets the selection to its initial position and size.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$reset(){const{x:t,y:e,width:i,height:s}=this.$initialSelection;return this.$change(t,e,i,s)}
/**
     * Clears the selection.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$clear(){this.$change(0,0,0,0,NaN,true);this.hidden=true;return this}
/**
     * Refreshes the position or size of the selection.
     * @returns {CropperSelection} Returns `this` for chaining.
     */$render(){return this.$setStyles({transform:`translate(${this.x}px, ${this.y}px)`,width:this.width,height:this.height})}
/**
     * Generates a real canvas element, with the image (selected area only) draw into if there is one.
     * @param {object} [options] The available options.
     * @param {number} [options.width] The width of the canvas.
     * @param {number} [options.height] The height of the canvas.
     * @param {Function} [options.beforeDraw] The function called before drawing the image onto the canvas.
     * @returns {Promise} Returns a promise that resolves to the generated canvas element.
     */$toCanvas(t){return new Promise(((e,i)=>{if(!this.isConnected){i(new Error("The current element is not connected to the DOM."));return}const s=document.createElement("canvas");let{width:h,height:n}=this;let o=1;if(C(t)&&(a(t.width)||a(t.height))){({width:h,height:n}=d({aspectRatio:h/n,width:t.width,height:t.height}));o=h/this.width}s.width=h;s.height=n;if(!this.$canvas){e(s);return}const r=this.$canvas.querySelector(this.$getTagNameOf(D));r?r.$ready().then((i=>{const a=s.getContext("2d");if(a){const[e,c,l,d,$,f]=r.$getTransform();const u=-this.x;const v=-this.y;const g=(u*d-l*v)/(e*d-l*c);const p=(v*e-c*u)/(e*d-l*c);let m=e*g+l*p+$;let b=c*g+d*p+f;let y=i.naturalWidth;let w=i.naturalHeight;if(o!==1){m*=o;b*=o;y*=o;w*=o}const k=y/2;const x=w/2;a.fillStyle="transparent";a.fillRect(0,0,h,n);C(t)&&E(t.beforeDraw)&&t.beforeDraw.call(this,a,s);a.save();a.translate(k,x);a.transform(e,c,l,d,m,b);a.translate(-k,-x);a.drawImage(i,0,0,y,w);a.restore()}e(s)})).catch(i):e(s)}))}}CropperSelection.$name=l;CropperSelection.$version="2.1.0";export{CropperSelection as default};

